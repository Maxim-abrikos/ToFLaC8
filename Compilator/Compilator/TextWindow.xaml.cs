
using System.Windows;
using System.Windows.Documents;

namespace Compiler
{
    /// <summary>
    /// Логика взаимодействия для TextWindow.xaml
    /// </summary>
    public partial class TextWindow : Window
    {
        private Dictionary<string, string> TextOfRCB = new Dictionary<string, string>() { {"Справка", "1. Введение\r\n\r\nЭтот документ предоставляет информацию о том, как использовать программу-компилятор комплексных чисел, разработанную на языке C#. Программа позволяет вычислять значения выражений, содержащих комплексные числа и основные арифметические операции.\r\n\r\n2. Установка и запуск\r\n\r\nТребования: Для работы программы требуется установленная среда выполнения .NET.\r\nЗапуск: Запустите исполняемый файл программы.\r\n3. Пользовательский интерфейс\r\n\r\nОсновное окно программы содержит:\r\n\r\nПоле ввода: Текстовое поле для ввода выражения с комплексными числами.\r\nКнопка “Вычислить”: Запускает процесс компиляции и вычисления выражения.\r\nПоле вывода: Текстовое поле для отображения результата вычисления или сообщения об ошибке.\r\n4. Формат ввода выражений\r\nПрограмма поддерживает следующие форматы записи комплексных чисел:\r\nДекартова форма (a + bi):\r\na - действительная часть (действительное число).\r\nb - мнимая часть (действительное число).\r\ni - мнимая единица.\r\nПримеры: 2 + 3i, -1 - 0.5i, 0 + 1i, 5 + i (когда мнимая часть равна 1). 5-i\r\nПолярная форма (r * e^(iθ) или r(cos(θ) + i*sin(θ)) ):\r\nr - модуль (действительное число).\r\nθ - аргумент в радианах или градусах (действительное число). Укажите, что поддерживается.\r\nПримеры: 5 * e^(i*pi/2), 2(cos(pi/4) + i*sin(pi/4)). (Требуется указать, как конкретно реализуется ввод полярной формы, если она есть.)\r\nПоддерживаемые операции:\r\nСложение: +\r\nВычитание: -\r\nУмножение: *\r\nДеление: /\r\nПримеры выражений:\r\n2 + 3i + 1 - i\r\n(4 + 2i) * (1 - i)\r\n(5 - i) / (2 + 2i)" }, 
            {"О программе", "О программе:\r\n\r\nДанная программа представляет собой компилятор, разработанный на языке C#, для выполнения операций с комплексными числами.  Он обеспечивает:\r\n\r\n*   **Парсинг выражений:** Анализ и разбор строковых выражений, содержащих комплексные числа в различных форматах.\r\n*   **Вычисление:** Поддержку основных арифметических операций (+, -, *, /) над комплексными числами.\r\n*   **Обработку ошибок:** Обнаружение и сообщение об ошибках в входных выражениях.\r\n*   **Вывод результатов:** Отображение вычисленных комплексных чисел в удобном формате.\r\n\r\nПрограмма предназначена для помощи разработчикам и исследователям, работающим с комплексными числами." }
            ,{"Грамматика","1.\t<DEF> -> ‘Complex’•IDENT\r\n2.\tIDENT -> letter•IDREM\r\n3.\tIDREM -> letter • IDREM | digit• IDREM| _IDREM| ‘=’NEW\r\n4.\tNEW -> ‘new’•TYPE\r\n5.\tTYPE -> ‘Complex’•CONSTRUCTOR\r\n6.\tCONSTRUCTOR -> ‘(’ •SIGN\r\n7.\tSIGN -> ‘-’ •NUMBERS | NUMBERS\r\n8.\tNUMBERS -> digit • NUM\r\n9.\tNUM -> digit • REAL | ‘.’REAL | ‘,’ IMAGINARY\r\n10.\tREAL -> digit • REALREM\r\n11.\tREALREM -> digit•REALREM | ‘,’IMAGINARYSIGN\r\n12.\tIMAGINARYSIGN -> IMAGINARY | ‘-’ • IMAGINARY\r\n13.\tIMAGINARY -> digit • INTIMAGINARY\r\n14.\tINTIMAGINARY -> digit • INTIMAGINARY| ‘.’INTIMAGINARYREM | ‘)’ •END\r\n15.\tINTIMAGINARYREM -> digit • INTIMAGINARYREM | ‘)’ •END\r\n16.\tEND -> ‘;’\r\n17.\t<letter> -> \"a\" | \"b\" | \"c\" | ... | \"z\" | \"A\" | \"B\" | \"C\" | ... | \"Z\" |\r\n<digit> -> \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\r\nСледуя введенному формальному определению грамматики, представим G[<DEF>] ее составляющими:\r\n•\tZ = G[<DEF >] ;\r\n•\tVT = {a, b, c, ..., z, A, B, C, ..., Z, +, -, ;, ,, .,0, 1, 2, ..., 9};\r\n•\tVN = {<DEF>, <IDENT>, <IDREM>, <NEW>, <TYPE>, <CONSTRUCTOR>, <SIGN>, <NUMBERS>,<NUM>, <REAL>, <REALREM>, < IMAGINARYSIGN >, <IMAGINARY>, <INTIMAGINARY>, <IMAGINARYREM>, <END>}\r\n" },
            {"Задание","В C# для объявления и инициализации комплексного числа используется структура System.Numerics.Complex. Эта структура позволяет представить комплексное число как пару чисел с плавающей точкой, представляющих действительную и мнимую части. После объявления переменной типа Complex, ей можно присвоить значение, представляющее комплексное число, которое в дальнейшем не будет изменяться (хотя сама переменная может быть переназначена).\r\nФормат записи: “Complex $name = new Complex ($value, $value);”\r\nПараметр $name передает имя переменной, а параметр $value - ее значения. Значение может быть целым (int), дробным (float, double, exp).\r\nПримеры:\r\n1.\tComplex Perem = new Complex (2, 0);\r\n2.\tComplex Perem = new Complex (3.4, -5.7f);   \r\n3.\tComplex Perem = new Complex (1.23e-4f, 1.23e-4f);\r\n" }
        ,{"Классификация", "Н. Хомский выделил четыре класса грамматик: грамматики нулевого типа, контекстно-зависимые, контекстно-свободные и автоматные грамматики. Вид грамматики определяется исходя из формы записи ее правил.\r\nГрамматики нулевого типа имеют правила следующего вида:\r\nα→β,\r\nгде α ∈ V*, V = Vт ⋃ VN, β ∈ V*.\r\nКонтекстно-зависимые грамматики (КЗграмматики) имеют правила следующего вида:\r\nγ1Aγ2 → γ1βγ2,\r\nгде A ∈ VN, β∈V+, γ1∈V* и γ2∈V*.\r\nКонтекстно-свободные грамматики имеют правила следующего вида:\r\nA → a,\r\nгде A∈VN, α∈V*.\r\nАвтоматные или регулярные грамматики имеют самые строгие ограничения на форму записи правил:\r\nA → aB | a | ε,\r\nгде a∈VТ, A∈VN и B∈VB.\r\nСогласно приведённым выше правилам, грамматика G[<DEF>] является автоматной грамматикой, т.к. здесь в левой части правил находится только по одному нетерминальному символу, а в правой – либо один терминальный и один нетерминальный символ, либо один терминальный символ.\r\n"},
            {"Литература","1.\tШорников Ю.В. Теория языков программирования: проектирование и реализация : учебное пособие / Ю. В. Шорников. – Новосибирск: Изд-во НГТУ, 2022. – 290 с. \r\n2.\tБиллиг, В. А. Основы программирования на С# / В.А. Биллиг. - М.: Интернет-университет информационных технологий, Бином. Лаборатория знаний, 2021. - 488 c.\r\n3.\tВагнер, Билл С# Эффективное программирование / Билл Вагнер. - М.: ЛОРИ, 2021. - 320 c.\r\n" },
            {"Код" ,"using System.Windows;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Documents;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Windows.Media;\r\nusing Compiler;\r\nusing System.Windows.Threading;\r\nusing System.Diagnostics;\r\nusing System.ComponentModel;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Windows.Input;\r\nusing Microsoft.Win32;\r\n\r\nusing Path = System.IO.Path;\r\nusing Color = System.Windows.Media.Color;\r\nusing Clipboard = System.Windows.Forms.Clipboard;\r\nusing TextDataFormat = System.Windows.Forms.TextDataFormat;\r\nusing MessageBox = System.Windows.Forms.MessageBox;\r\nusing Application = System.Windows.Application;\r\nusing OpenFileDialog = Microsoft.Win32.OpenFileDialog;\r\n\r\nusing System.Windows.Forms;\r\n\r\nnamespace Compilator\r\n{\r\n    public partial class MainWindow : Window\r\n    {\r\n        private string fileName;\r\n        private string filePath;\r\n        private string filesFolderPath;\r\n        private DispatcherTimer timer;\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;\r\n            string projectDirectory = Directo-ry.GetParent(Directory.GetParent(baseDirectory).FullName).FullName;\r\n            filesFolderPath = Path.Combine(Directory.GetParent(projectDirectory).FullName, \"Files\");\r\n            timer = new DispatcherTimer();\r\n            timer.Interval = TimeSpan.FromMilliseconds(200);\r\n            timer.Tick += Timer_Tick;\r\n        }\r\n\r\n\r\n        private void Timer_Tick(object sender, EventArgs e)\r\n        {\r\n            timer.Stop();\r\n            ColorizeRichTextBox(RCB1);\r\n        }\r\n\r\n        private void RichTextBox_TextChanged(object sender, TextChangedEventArgs e)\r\n        {\r\n        }\r\n\r\n        private void MakeNewFile(object sender, RoutedEventArgs e)\r\n        {\r\n            CreateWindow createFileWindow = new CreateWindow();\r\n            createFileWindow.Closed += CreateFileDialog_Closed;\r\n            createFileWindow.ShowDialog();\r\n        }\r\n\r\n        private void CreateFileDialog_Closed(object sender, EventArgs e)\r\n        {\r\n            fileName = ((CreateWindow)sender).FileName;\r\n            filePath = Path.Combine(filesFolderPath, fileName);\r\n            if (!Directory.Exists(filesFolderPath))\r\n            {\r\n                try\r\n                {\r\n                    Directory.CreateDirectory(filesFolderPath);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    MessageBox.Show(\"Ошибка при создании папки Files: \" + ex.Message);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            try\r\n            {\r\n                File.WriteAllText(filePath, \"Hello\");\r\n                textEditor.Clear();\r\n                textEditor.Text += \"Hello\";\r\n\r\n                MessageBox.Show(\"Файл успешно создан: \" + fileName);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                MessageBox.Show(\"Ошибка при создании файла: \" + ex.Message);\r\n            }\r\n        }\r\n\r\n        private void SaveFile_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            try\r\n            {\r\n                File.WriteAllText(filePath, textEditor.Text);  // Используем File.WriteAllText\r\n                MessageBox.Show(\"Сохранено успешно\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                MessageBox.Show(\"Ошибка сохранения: \" + ex.Message);\r\n            }\r\n        }\r\n\r\n        private void BackButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            textEditor.Undo();\r\n\r\n        }\r\n\r\n        private void ForwardButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            textEditor.Redo();\r\n        }\r\n\r\n        private void DeleteAll(object sender, RoutedEventArgs e)\r\n        {\r\n            textEditor.Clear();\r\n        }\r\n\r\n        private void RCB1_TextChanged(object sender, TextChangedEventArgs e)\r\n        {\r\n            //Dispatcher.InvokeAsync(HighlightLastWord, DispatcherPriori-ty.ContextIdle);\r\n        }\r\n\r\n\r\n        private void CopyButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            string selectedText = textEditor.SelectedText;\r\n            if (!string.IsNullOrEmpty(selectedText))\r\n            {\r\n                Clipboard.SetText(selectedText);\r\n            }\r\n        }\r\n\r\n        private void CutButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            if (!string.IsNullOrEmpty(textEditor.SelectedText))\r\n            {\r\n                Clipboard.SetText(textEditor.SelectedText);\r\n                textEditor.SelectedText = \"\";\r\n            }\r\n        }\r\n\r\n        private void PasteButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            if (Clipboard.ContainsText(TextDataFormat.Rtf))\r\n            {\r\n                try\r\n                {\r\n                    string rtfText = Clipboard.GetText(TextDataFormat.Rtf);\r\n                    textEditor.SelectedText = rtfText;\r\n\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    MessageBox.Show(\"Ошибка при вставке RTF: \" + ex.Message);\r\n                }\r\n            }\r\n            else if (Clipboard.ContainsText())\r\n            {\r\n                string clipboardText = Clipboard.GetText();\r\n                textEditor.SelectedText = clipboardText;\r\n            }\r\n        }\r\n\r\n\r\n        private void ExitApp(object sender, RoutedEventArgs e)\r\n        {\r\n            this.Close();\r\n        }\r\n\r\n        private void OpenFile_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            OpenFileDialog openFileDialog = new OpenFileDialog();\r\n            openFileDialog.Multiselect = false;\r\n            openFileDialog.Filter = \"Текстовые файлы (*.txt)|*.txt|Все файлы (*.*)|*.*\";\r\n            if (openFileDialog.ShowDialog() == true)\r\n            {\r\n                try\r\n                {\r\n                    string filepath = openFileDialog.FileName;\r\n                    string fileContent = File.ReadAllText(filepath);\r\n                    textEditor.Text = \"\";\r\n                    textEditor.Text += fileContent;\r\n                    filePath = filepath;\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    MessageBox.Show(ex.ToString());\r\n                }\r\n            }\r\n        }\r\n\r\n        private void ManualButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            TextWindow textWindow = new TextWindow(\"Справка\");\r\n            textWindow.ShowDialog();\r\n        }\r\n\r\n        private void AboutProgrammButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            TextWindow textWindow = new TextWindow(\"О программе\");\r\n            textWindow.ShowDialog();\r\n        }\r\n\r\n        private void TryToExit(object sender, CancelEventArgs e)\r\n        {\r\n            e.Cancel = true;\r\n            ExitWindow confirmationWindow = new ExitWindow();\r\n            if (confirmationWindow.ShowDialog() == true)\r\n            {\r\n                e.Cancel = false;\r\n                Application.Current.Shutdown();\r\n            }\r\n        }\r\n\r\n\r\n        private void StartButton_Click(object sender, RoutedEventArgs e)\r\n        {\r\n            RCB2.Document.Blocks.Clear();\r\n            List<string> ToWrite = LeksAnalisation.Analyze(textEditor);\r\n            if (ToWrite != null)\r\n                foreach (var token in ToWrite)\r\n                    RCB2.AppendText(token + \"\\n\");\r\n            else\r\n                RCB2.AppendText(\"Ошибок нет\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninternal static class LeksAnalisation\r\n{\r\n    private static readonly HashSet<string> _variables = new HashSet<string>();\r\npublic static int GetIndexAfterSecondWordRegex(string input)\r\n{\r\n    Match match = Regex.Match(input, @\"^(\\S+\\s+){2}\");\r\n\r\n    if (!match.Success)\r\n    {\r\n        return -1; // Не найдено два слова.\r\n    }\r\n\r\n    // Возвращаем индекс, где заканчивается совпадение (то есть, после второго слова и разделителя).\r\n    return match.Length;\r\n} \r\nstatic List<int> GetStartIndicesOfElements(string input)\r\n{\r\n    List<int> indices = new List<int>();\r\n    // Регулярное выражение для поиска:\r\n    // - слов (например, \"Complex\", \"s\", \"new\"),\r\n    // - чисел (например, \"3\", \"0\"),\r\n    // - отдельных символов (например, \"=\", \"(\", \",\", \")\", \";\").\r\n    string pattern = @\"[a-zA-Z_]\\w*|\\d+|[^\\w\\s]\";\r\n\r\n    MatchCollection matches = Regex.Matches(input, pattern);\r\n\r\n    foreach (Match match in matches)\r\n    {\r\n        if (match.Success)\r\n        {\r\n            indices.Add(match.Index);\r\n        }\r\n    }\r\n\r\n    return indices;\r\n}\r\n\r\nstatic List<string> SplitTokens(string input)\r\n{\r\n    List<string> tokens = new List<string>();\r\n    string pattern = @\"(-?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?)|([a-zA-Zа-яА-Я_]\\w*)|([=(),])|\\s+\";\r\n\r\n    MatchCollection matches = Regex.Matches(input, pattern);\r\n\r\n    foreach (Match match in matches)\r\n    {\r\n        string value = match.Value.Trim();\r\n        if (!string.IsNullOrEmpty(value))\r\n        {\r\n            tokens.Add(value);\r\n        }\r\n                \r\n    }\r\n    MessageBox.Show(tokens.Count().ToString());\r\n    return tokens;\r\n}\r\nstatic Dictionary<int, string> Words = new Dictionary<int, string>() { {0, \"Complex\" }, { 1, @\"^@?[a-zA-Z_]\\w*$\" }, { 2,\"=\" },{3,\"new\" },{ 4,\"Complex\" },{5,\"(\" }, {6, @\"^[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?f?$\" }, {7,\",\" }, {8,\"ffff\" },  };\r\n\r\n\r\n\r\n\r\n    private static readonly HashSet<char> InvalidChars = new HashSet<char>\r\n{\r\n    '@', '#', '!', '&', '*', '[', ']', '{', '}', '~', '$', '%', '^', '`', '\\\\', '|', '<', '>', '?', ':', '/', '\"',\r\n};\r\n\r\n        private class TokenPattern\r\n        {\r\n            public string Type { get; }\r\n            public string Pattern { get; }\r\n            public string Description { get; }\r\n            public bool IsCritical { get; }\r\n\r\n            public TokenPattern(string type, string pattern, string description, bool isCritical = false)\r\n            {\r\n                Type = type;\r\n                Pattern = pattern;\r\n                Description = description;\r\n                IsCritical = isCritical;\r\n            }\r\n        }\r\n    private static readonly List<TokenPattern> ExpectedPatterns = new List<TokenPattern>\r\n{\r\n    new TokenPattern(\"Complex1\", \"Complex\", \"первое 'Complex'\", true),\r\n    new TokenPattern(\"Name\", @\"[a-zA-Z_][a-zA-Z0-9_]*\", \"имя переменной\"),\r\n    new TokenPattern(\"Assign\", \"=\", \"оператор '='\"),\r\n    new TokenPattern(\"New\", \"new\", \"'new'\", true),\r\n    new TokenPattern(\"Complex2\", \"Complex\", \"второе 'Complex'\", true),\r\n    new TokenPattern(\"OpenParen\", \"(\", \"'('\"),\r\n    new TokenPattern(\"Number1\", @\"[+-]?(\\d+\\.?\\d*|\\.\\d+)([eE][+-]?\\d+)?[fFdDmM]?\", \"первое число\"),\r\n    new TokenPattern(\"Comma\", \",\", \"','\"),\r\n    new TokenPattern(\"Number2\", @\"[+-]?(\\d+\\.?\\d*|\\.\\d+)([eE][+-]?\\d+)?[fFdDmM]?\", \"второе число\"),\r\n    new TokenPattern(\"CloseParen\", \")\", \"')'\"),\r\n    new TokenPattern(\"Semicolon\", \";\", \"';'\")\r\n};\r\nprivate static List<string> RegularTokens = new List<string>() { \"Complex\", @\"^[a-zA-Z_][a-zA-Z0-9_]*$\", @\"=\", \"new\", \"Complex\", @\"(\", @\"^-?\\d+(\\.\\d+)?(f|e[-+]?\\d+)?$\", @\",\", @\"^-?\\d+(\\.\\d+)?(f|e[-+]?\\d+)?$\", @\")\", @\";\" };\r\nprivate static Dictionary<string, string> TokenNameMap = new Dictionary<string, string>()\r\n{\r\n    { @\"^[a-zA-Z_][a-zA-Z0-9_]*$\", \"имя переменной\" },\r\n    { @\"^-?\\d+(\\.\\d+)?(f|e[-+]?\\d+)?$\", \"число\" },\r\n    { \"(\", \"(\" }, // Добавлено для левой скобки\r\n    { \")\", \")\" },  // Добавлено для правой скобки\r\n    { \";\", \";\" }  // Добавлено для точки с запятой\r\n};\r\npublic static List<string> Analyze(TextEditor textEditor)\r\n{\r\n    var results = new List<string>();\r\n    var document = textEditor.Document;\r\n\r\n    for (int i = 0; i < document.LineCount; i++)\r\n    {\r\n        int lineNumber = i + 1; // Номер текущей строки\r\n        bool hasErrorsInLine = false; // Флаг для отслеживания ошибок в текущей строке\r\n\r\n        List<bool> RegularTokensExistance = new List<bool>(new bool[RegularTokens.Count]);\r\n        (string cleaned, List<(int, int)> ranges, List<string> substrings) = Clean-String(document.GetText(document.GetLineByNumber(i + 1)));\r\n\r\n        if (substrings.Count > 0)\r\n        {\r\n            hasErrorsInLine = true;\r\n            for (int h = 0; h < substrings.Count; h++)\r\n            {\r\n                results.Add($\"Строка {lineNumber}: Обнаружен недопустимый токен: \" + substrings[h] + \" с \" + ranges[h].Item1 + \" по \" + ranges[h].Item2 + \"\\n\");\r\n            }\r\n        }\r\n\r\n        List<(string Token, int Index)> Smth = Tokenize(cleaned);\r\n        int tokenIndex = 0;\r\n        int expectedTokenIndex = 0;\r\n\r\n        while (tokenIndex < Smth.Count)\r\n        {\r\n            bool foundMatch = false;\r\n            for (int j = expectedTokenIndex; j < RegularTokens.Count; j++)\r\n            {\r\n                if (!RegularTokensExistance[j])\r\n                {\r\n                    if (Smth[tokenIndex].Token == RegularTokens[j])\r\n                    {\r\n                        RegularTokensExistance[j] = true;\r\n                        foundMatch = true;\r\n                        expectedTokenIndex = j + 1;\r\n                        tokenIndex++;\r\n                        break;\r\n                    }\r\n                    else\r\n                    {\r\n                        try\r\n                        {\r\n                            if (Regex.IsMatch(Smth[tokenIndex].Token, RegularTo-kens[j]))\r\n                            {\r\n                                if (j == 1 && (Smth[tokenIndex].Token == \"Complex\" || Smth[tokenIndex].Token == \"new\"))\r\n                                {\r\n                                    hasErrorsInLine = true;\r\n                                    results.Add($\"Строка {lineNumber}: Ошибка: Нельзя использовать ключевое слово '\" + Smth[tokenIndex].Token + \"' в качестве имени перемен-ной.\\n\");\r\n                                    foundMatch = true;\r\n                                    tokenIndex++;\r\n                                    break;\r\n                                }\r\n\r\n                                RegularTokensExistance[j] = true;\r\n                                foundMatch = true;\r\n                                expectedTokenIndex = j + 1;\r\n                                tokenIndex++;\r\n                                break;\r\n                            }\r\n                        }\r\n                        catch (ArgumentException) { /* Обработка исключения */ }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!foundMatch)\r\n            {\r\n                hasErrorsInLine = true;\r\n                results.Add($\"Строка {lineNumber}: Лишний или неверный токен: \" + Smth[tokenIndex].Token + \" на позиции: \" + Smth[tokenIndex].Index + \"\\n\");\r\n                tokenIndex++;\r\n            }\r\n        }\r\n\r\n        for (int j = 0; j < RegularTokens.Count; j++)\r\n        {\r\n            if (!RegularTokensExistance[j])\r\n            {\r\n                hasErrorsInLine = true;\r\n                string tokenName = RegularTokens[j];\r\n                if (TokenNameMap.ContainsKey(RegularTokens[j]))\r\n                {\r\n                    tokenName = TokenNameMap[RegularTokens[j]];\r\n                }\r\n                results.Add($\"Строка {lineNumber}: Отсутствует обязательный токен: \" + tokenName + \"\\n\");\r\n            }\r\n        }\r\n\r\n        // Добавляем сообщение об отсутствии ошибок, если ошибок не было\r\n        if (!hasErrorsInLine)\r\n        {\r\n            results.Add($\"Строка {lineNumber}: Ошибки не найдены.\\n\");\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n    public static List<(string Token, int Index)> Tokenize(string text)\r\n    {\r\n        var tokens = new List<(string, int)>();\r\n        int currentIndex = 0;\r\n\r\n        while (currentIndex < text.Length)\r\n        {\r\n            // Пропускаем пробелы\r\n            if (char.IsWhiteSpace(text[currentIndex]))\r\n            {\r\n                currentIndex++;\r\n                continue;\r\n            }\r\n\r\n            // Ищем идентификатор (переменную)\r\n            if (char.IsLetter(text[currentIndex]) || text[currentIndex] == '_')\r\n            {\r\n                int startIndex = currentIndex;\r\n                while (currentIndex < text.Length && (char.IsLetterOrDigit(text[currentIndex]) || text[currentIndex] == '_'))\r\n                {\r\n                    currentIndex++;\r\n                }\r\n                string identifier = text.Substring(startIndex, currentIndex - startIn-dex);\r\n                tokens.Add((identifier, startIndex));\r\n                continue;\r\n            }\r\n\r\n            // Ищем число\r\n            if (char.IsDigit(text[currentIndex]) || text[currentIndex] == '-')\r\n            {\r\n                int startIndex = currentIndex;\r\n                //Более сложная логика разбора числа (с учетом десятичной точки, экс-поненты и т.д.)\r\n                while (currentIndex < text.Length && (char.IsDigit(text[currentIndex]) || text[currentIndex] == '.' || text[currentIndex] == 'e' || text[currentIndex] == 'E' || text[currentIndex] == '+' || text[currentIndex] == '-' || char.ToLower(text[currentIndex]) == 'f')) // Добавлено char.ToLower(text[currentIndex]) == 'f'\r\n                {\r\n                    currentIndex++;\r\n                }\r\n                string number = text.Substring(startIndex, currentIndex - startIndex);\r\n                tokens.Add((number, startIndex));\r\n                continue;\r\n            }\r\n\r\n            // Если не идентификатор и не число, считаем это отдельным токеном (опера-тор, скобка и т.д.)\r\n            tokens.Add((text[currentIndex].ToString(), currentIndex));\r\n            currentIndex++;\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n\r\n    public static (string cleanedString, List<(int startIndex, int endIndex)> re-movedRanges, List<string> removedSubstrings) CleanString(string input)\r\n    {\r\n        if (string.IsNullOrEmpty(input))\r\n        {\r\n            return (input, new List<(int, int)>(), new List<string>());\r\n        }\r\n\r\n        StringBuilder cleanedString = new StringBuilder();\r\n        List<(int startIndex, int endIndex)> removedRanges = new List<(int, int)>();\r\n        List<string> removedSubstrings = new List<string>();\r\n        int removalStart = -1;\r\n\r\n        for (int i = 0; i < input.Length; i++)\r\n        {\r\n            if (InvalidChars.Contains(input[i]))\r\n            {\r\n                if (removalStart == -1)\r\n                {\r\n                    removalStart = i;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (removalStart != -1)\r\n                {\r\n                    removedRanges.Add((removalStart, i - 1));\r\n                    removedSubstrings.Add(input.Substring(removalStart, i - remov-alStart)); // Извлекаем подстроку\r\n                    removalStart = -1;\r\n                }\r\n                cleanedString.Append(input[i]);\r\n            }\r\n        }\r\n\r\n        if (removalStart != -1)\r\n        {\r\n            removedRanges.Add((removalStart, input.Length - 1));\r\n            removedSubstrings.Add(input.Substring(removalStart)); // Извлекаем под-строку\r\n        }\r\n\r\n        return (cleanedString.ToString(), removedRanges, removedSubstrings);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninternal class Token\r\n{\r\n    public string Text { get; }\r\n    public int StartIndex { get; }\r\n    public int EndIndex { get; }\r\n    public int Code { get; }\r\n    public string Category { get; }\r\n\r\n    public Token(string text, int startIndex, int endIndex)\r\n    {\r\n        Text = text;\r\n        StartIndex = startIndex;\r\n        EndIndex = endIndex;\r\n        Code = GetTokenCode(text);\r\n        Category = GetTokenCategory(text);\r\n    }\r\n\r\n    public string IndexInfo => StartIndex == EndIndex ? $\"{StartIndex}\" : $\"с {Start-Index} по {EndIndex}\";\r\n\r\n    private int GetTokenCode(string text)\r\n    {\r\n        switch (text)\r\n        {\r\n            case \"Complex\": return 1;\r\n            case \"new\": return 2;\r\n            case \" \": return 3;\r\n            case \"=\": return 5;\r\n            case \"(\": return 7;\r\n            case \")\": return 8;\r\n            case \",\": return 9;\r\n            case \";\": return 10;\r\n            default:\r\n                if (Regex.IsMatch(text, @\"^[a-zA-Z_][a-zA-Z0-9_]*$\")) return 4; // Идентификатор\r\n                if (Regex.IsMatch(text, @\"^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$\")) return 6; // Число\r\n                return -1; // Неизвестная лексема\r\n        }\r\n    }\r\n\r\n    private string GetTokenCategory(string text)\r\n    {\r\n        switch (text)\r\n        {\r\n            case \"Complex\": return \"Ключевое слово\";\r\n            case \"new\": return \"Ключевое слово\";\r\n            case \" \": return \"Разделитель\";\r\n            case \"=\": return \"Оператор присваивания\";\r\n            case \"(\": return \"Ограничитель\";\r\n            case \")\": return \"Ограничитель\";\r\n            case \",\": return \"Разделитель\";\r\n            case \";\": return \"Конец оператора\";\r\n            default:\r\n                if (Regex.IsMatch(text, @\"^[a-zA-Z_][a-zA-Z0-9_]*$\")) return \"Иденти-фикатор\";\r\n                if (Regex.IsMatch(text, @\"^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$\")) return \"Число\";\r\n                return \"Неизвестная лексема\";\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nnamespace Compiler\r\n{\r\n    internal static class Painter\r\n    {\r\n        //public static List<Color> ColorsOfTheText = new List<Color>();\r\n\r\n        public static readonly Dictionary<string, Color> ColorBook = new Diction-ary<string, Color>() {\r\n            { \"new\", Colors.Blue },\r\n            { \"Complew\", Colors.Blue },\r\n            };\r\n        \r\n    }\r\n}\r\npublic TextWindow(string text)\r\n    {\r\n        InitializeComponent();\r\n        this.Title = text;\r\n        BaseRCB.Document.Blocks.Clear();\r\n        BaseRCB.Document.Blocks.Add(new Paragraph(new Run(TextOfRCB[text])));\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npublic partial class CreateWindow : Window\r\n{\r\n    public string FileName { get; set; }\r\n    public CreateWindow()\r\n    {\r\n        InitializeComponent();\r\n    }\r\n\r\n    private void MegaButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        string fileName = TBFileName.Text.Trim();\r\n\r\n        // Проверка имени файла (допустимые символы, длина, и т.д.)\r\n        if (IsValidFileName(fileName))\r\n        {\r\n            FileName = fileName; // Сохраняем имя файла\r\n            DialogResult = true;  // Закрываем окно с результатом \"OK\"\r\n            Close();\r\n        }\r\n        else\r\n        {\r\n            MessageBox.Show(\"Недопустимое имя файла.\");\r\n        }\r\n    }\r\n\r\n    private bool IsValidFileName(string fileName)\r\n    {\r\n        // Пример: проверяем, что имя файла не пустое и не содержит недопустимых сим-волов\r\n        if (string.IsNullOrEmpty(fileName)) return false;\r\n        if (fileName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) return false;\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n"},
            {"Метод","Проверка производится поэтапно:\r\n1)\tСначала программа посимвольно проверяет строку на наличие запрещённых символов. Программа помечает “проблемные” места, где находятся подстроки запрещённых символов, затем удаляет их и соединяет оставшиеся подстроки. Все удалённые подстроки заносятся в список ошибок.\r\n2)\tПрограмма возвращается в начало строки и движется уже не по символам, а по токенам. Токеном может быть число, символ и слово. Далее программа проходит по токенам и сравнивает полученный с ожидаемым. Если они совпали, то программа идёт дальше. Если нет, то: программа идёт до конца строки в поисках нужного токена. Если такой найден, то все токены между ним и предыдущим обязательным отбрасываются с пометкой об их ошибочности. В противном случае программа обозначит искомый токен пропущенные и перейдёт к поиску следующего. \r\n" } };
        public TextWindow(string text)
        {
            InitializeComponent();
            this.Title = text;
            BaseRCB.Document.Blocks.Clear();
            BaseRCB.Document.Blocks.Add(new Paragraph(new Run(TextOfRCB[text])));
        }
    }
}
